# -*- coding: utf-8 -*-
"""Meros 1 KAI 2 YLOPOIHMENO ONTWS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sTzVsFM_EWIdpy84sQHoXKw9vARY5keE
"""

#ΦΟΙΤΗΤΕΣ-ΕΠΙΜΕΛΕΙΑ:
#Βόικος Στέφανος με Α.Μ: el18162
#Μιχαλίτσης Αλκιβιάδης με Α.Μ: el18868

#ΑΠΑΝΤΗΣΕΙΣ ΤΩΝ ΜΕΡΩΝ ΤΗΣ 1ΗΣ ΕΡΓΑΣΤΗΡΙΑΚΗΣ ΑΣΚΗΣΗΣ ΣΤΗΝ "ΤΕΧΝΗΤΗ ΝΟΗΜΟΣΥΝΗ"

#ΜΕΡΟΣ 1ο:

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
from queue import LifoQueue
from PIL import Image
from matplotlib import image
import random 
import time
import matplotlib.pyplot as plt
from numpy import asarray
from collections import deque

class Maze:
    def __init__(self, N, S, F):

        """
        N: integer that indicates the size of the NxN grid of the maze
        S: pair of integers that indicates the coordinates of the starting point (S)
        F: pair of integers that indicates the coordinates of the finish point (F)
        You can add any other parameters you want to customize maze creation (e.g. variables that
        control the creation of additional paths)
        """
  
        assert N > 2

        ## Make sure start and end are within the grid

        assert S[0] < N-1
        assert S[1] < N-1
        assert F[0] < N-1
        assert F[1] < N-1
  
        assert S[0] > 0
        assert S[1] > 0
        assert F[0] > 0
        assert F[1] > 0
  
        # Add here any additional constraints your implementation may have
    
        self.N = N
        self.S = S
        self.F = F
  
        # Grid initialized with obstacles (array of 0/False)
        # 1/True indicates available cells
        self.grid = np.zeros((N, N), dtype=bool)
        #print(self.grid)
        if N == 11: 
            images = Image.open("index1.png")
            pix1 = images.load()
            datas = asarray(images)
        elif N == 25: 
            images = Image.open("index2.png")
            pix1 = images.load()
            datas = asarray(images)
        elif N == 41: 
            images = Image.open("index4.png")
            pix1 = images.load()
            datas = asarray(images)
        elif N == 51: 
            images = Image.open("index3.png")
            pix1 = images.load()
            datas = asarray(images)
        else:
            print("We will need some more examples so as to make something really simular and good")
        #print(type(data))
        #print(data.shape)
        print(S[0])
        print(S[1])
        #print(data)
        #plt.imshow(images)
        #plt.show()
        GREEN = []
        RED = []
        initial = np.array([50, 168, 64, 255])
        ending = np.array([168, 50, 50, 255])
    
        def checking(array1,array2):
            if len(array1) != len(array2): return False
            if len(array1) == 0 : return False
            if len(array2) == 0 : return False
            for i in range(0,len(array1)):
                #if array1[0] == 50 :
                    #print("Array 1 is {} and array2 is {} ".format(array1,array2))
                if(array1[i] != array2[i]):
                    return False
            return True
    
        #print(data[0][0][0])
        #print(data[0][0][1])
        #print(data[0][0][2])
        #print(data[0][0][3])
        print(datas.shape)
        print("\n the pixels are: \n")
        for i in range(0,len(datas)):
            for j in range(0,len(datas[i])):
                #print(data[i][j])
                if checking(datas[i][j],initial):
                    GREEN.append((i,j))
                    #print("YES EXIST")
                if checking(datas[i][j],ending):
                    RED.append((i,j))
                    #print("YES EXIST")
        if N == 25:
            print("GREEN is : {}".format(GREEN))
        if N == 41:
            print("GREEN is : {}".format(GREEN))
        if N == 51:
            print("GREEN is : {}".format(GREEN))
            print("RED is : {}".format(RED))
        def find_colour(xrwma):
            if checking(xrwma,[0,0,0,0]) or checking(xrwma,[0,0,0,255]) :
                return 0 #"black" data[i][j]
            if checking(xrwma,[255,255,255,0]) or checking(xrwma,[255,255,255,255]) :
                return 1 #"white"
            if checking(xrwma,[168,50,50,255]) :
                return 2 #"green"
            if checking(xrwma,[50, 168, 64, 255]) or checking(xrwma,[50, 168, 64, 0]) :
                return 3 #"red"
        #print("GREEN IS : {}".format(GREEN))
        #print("RED IS : {}".format(RED))
        ## YOUR  CODE HERE
        #ONCE I MANAGED, I CREATE A MAP 11x11 
        self.xartis = np.zeros((self.N,self.N),dtype=int)
        self.unvisited = []
        #print(type(xartis))
        if N == 11:
            for i in range(0,self.N):
                for j in range(0,self.N):
                    self.xartis[i][j] = find_colour(datas[7+20*i][11+20*j])
                    if self.xartis[i][j] != 0:
                        self.unvisited.append((i,j))
            print("The final xartis is : \n {}".format(self.xartis))
        if N == 25:
            for i in range(0,self.N):
                for j in range(0,self.N):
                    self.xartis[i][j] = find_colour(datas[7+9*i][12+9*j])
                    if self.xartis[i][j] != 0:
                        self.unvisited.append((i,j))
            print("The final xartis is : \n {}".format(self.xartis))
        if N == 41:
            for i in range(0,self.N):
                for j in range(0,self.N):
                    #print(type(xartis[i][j]))
                    self.xartis[i][j] = find_colour(datas[2+10*i][4+10*j])
                    if self.xartis[i][j] != 0:
                        self.unvisited.append((i,j))
            print("The final xartis is : \n {}".format(self.xartis))
        if N == 51:
            for i in range(0,self.N):
                for j in range(0,self.N):
                    self.xartis[i][j] = find_colour(datas[9+4*i][9+4*j])
                    if self.xartis[i][j] != 0:
                        self.unvisited.append((i,j))
            print("The final xartis is : \n {}".format(self.xartis))
        #Εδώ φτιάξε τον λαβύρινθο. 
        #Εγινε η κωδικοποίηση και θα χρησιμοποιήσω τώρα DFS συνάρτηση:
    def draw_map(self,path=None):
        """ Draws the maze as an image. Considers grid values of 0/False to represent obstacles and
        values of 1/True to represent empty cells, but this can be customized. Obstacles are painted
        black and empty cells are painted white. Starting point is painted green and finish point red.
        Optionally accepts as a parameter a path within the maze which is painted blue. 
        """
        image = np.zeros((self.N, self.N, 3), dtype=int)
        image[~self.grid] = [0, 0, 0] #black
        image[self.grid] = [255, 255, 255] #white

        # Uncomment the next 2 lines of code to treat 1/True as obstacles (and 0/False as free maze cells)
        #image[self.grid] = [0, 0, 0]
        #image[~self.grid] = [255, 255, 255]

        image[self.S] = [50, 168, 64]
        image[self.F] = [168, 50, 50]
        if path:
            for n in path[1:-1]:
                image[n] = [66, 221, 245]

        plt.imshow(image)
        plt.xticks([])
        plt.yticks([])
        plt.show()
        
    def DFS(self):
        isFound = False
        #curently_visited = [start]
        #print(unvisited) #Mia xara einai pragmati
        current = self.S
        self.grid[current[0]][current[1]] = True #Adiaforo afou tha ginei green,pio poly ta monopatia
        self.unvisited.remove(self.S)
        array = self.xartis #np.array(img)
        #print(array.shape)
        intersects = []
        while len(self.unvisited) != 0:
            possible = []
            surroundings = [(current[0]-1, current[1]), (current[0]+1, current[1]),(current[0], current[1]-1),(current[0], current[1]+1)]
            for move in surroundings:
                if self.F == move:
                    isFound = True
                #Pare to index kai des an einai toixos i otidipote
                #if (pix[move] >= (200,200,200, 0) and pix[move] != (255,255,0,0) and move != start):
                if (self.xartis[move[0]][move[1]] != 0 and move != self.S):
                    if move in self.unvisited:
                        possible.append(move)
            if len(possible) >= 2:
                if current not in intersects:
                    intersects.append(current)
                print(possible)
                current = random.choice(possible)
                self.unvisited.remove(current)
            elif len(possible) == 1:
                current = possible[0]
                self.unvisited.remove(current)
            elif len(possible) == 0:
                #Edw se adieksodo
                #print("EDW THN PATAW")
                intersects_reversed = intersects[::-1]
                for i in intersects_reversed:
                    if i != current:
                        current = i
                        #self.unvisited.remove(i)
                        intersects.pop(intersects.index(i))
                        break
                #paths = paths[:path.index(current)]
            #else:
            #    current = random.choice(possible)
            #paths.append(current)
            print(current)
            self.grid[current[0]][current[1]] = True #EDW SHMATNIKO
            #unvisited.remove(current)
            #time.sleep(2)
            #print("Length of array is " + str(len(array[0,0])))
            print(current[1])
            print(current[0])
            self.draw_map() #Για να δείχνεις βήμα β΄΄ήμα την απελευθέρωση του λαβύρινθου και την παραγωγή του. 
            #array[(current[1], current[0])] = (255,255,0)
            #img = Image.fromarray(array)
            #pix = img.load()
        #for p in paths:
        #    array[p[1], p[0]] = (0,255,0)
        #img = Image.fromarray(array)
        print("NAI ERXOMAI EDW")
        #img.save('solution.png')
                
#(11, (1, 3), (7, 9)), (25, (3, 7), (23, 19)),
for N, S, F in (11, (1, 3), (7, 9)), (25, (3, 7), (23, 19)):
    map = Maze(N, S, F)
    map.DFS()
#Εδώ όμως πρέπει να επεκταθεί το map και σε αυτό να μπουν νέα στοιχεία.
#map.draw_map()
#ΑΝ ΔΕΝ ΠΕΤΥΧΕΙ, ΒΑΛΕ ΕΝΑ ΑΛΛΟ ΠΑΡΑΔΕΙΓΜΑ, Η ΛΟΓΙΚΗ ΕΙΝΑΙ ΟΛΟΣΩΣΤΗ
#ΠΑΣ ΓΙΑ ΜΕΡΟΣ 2!!

#ΜΕΡΟΣ 2ο

#Ανάλυση του Αλγορίθμου Α* με βάση τις συναρτήσεις h(n) και g(n):

#g(n) = 0 τότε ο A* ταυτίζεται με τον άπληστο αλγόριθμο Best-First. Ο Best-First δεν μπορεί να εγγυηθεί την εύρεση του συντομότερου μονοπατιού επειδή κάθε φορά επιλέγει το πλησιέστερο στον στόχο κελί.

#h(n) = 0 τότε ο ο Α* εκφυλίζεται στον Dijkstra ο οποίος βρίσκει πάντα τα ελάχιστα μονοπάτια.

#Για g(n) = 1 η εύρεση ή όχι του ελάχιστου μονοπατιού εξαρτάται από τη σχέση των h(n), g(n).

#h<=g(n) τότε βρίσκει το ελάχιστο μονοπάτι

#h(n)>g(n) τότε ο Α* είναι πολύ γρήγορος στην εύρεση ενός μονοπατιού από τον S στον F χωρίς όμως να εγγυάται την εύρεση του ελάχιστου μονοπατιού

#h(n) >> g(n) ο Α* μετατρέπεται σε Greedy Best-First
#Ευριστικές συναρτήσεις (h(n)) που μπορούν να χρησιμοποιηθούν:

#Manhattan distance
#Euclidean distance

class visualization:
    def __init__(self, S, F):
        '''
          Η μέθοδος αυτή αρχικοποιεί ένα αντικείμενο τύπου visualization.
          Είσοδος: 
          -> S: το σημείο εκκίνσης της αναζήτησης
          -> F: το σημείο τερματισμού
        '''
        self.S = S
        self.F = F
        self.images = []
    
    def draw_step(self, grid, frontier, expanded_nodes):
        '''
          Η συνάρτηση αυτή καλείται για να σχεδιαστεί ένα frame στο animation (πρακτικά έπειτα από την επέκταση κάθε κόμβου)
          Είσοδος: 
          -> grid: Ένα χάρτης τύπου grid
          -> frontier: Μια λίστα με τους κόμβους που ανήκουν στο μέτωπο της αναζήτησης
          -> expanded_nodes: Μια λίστα με τους κόμβους που έχουν ήδη επεκταθεί
          Επιστρέφει: None
          Η συνάρτηση αυτή πρέπει να καλεστεί τουλάχιστον μια φορά για να μπορέσει να σχεδιαστει ένα animation (πρεπεί το animation να έχει τουλάχιστον ένα frame).
        '''
        image = np.zeros((grid.N, grid.N, 3), dtype=int)
        #image[~grid.grid] = [0, 0, 0]
        #image[grid.grid] = [255, 255, 255]
        # Use this to treat 1/True as obstacles
        image[grid.xartis == 0] = [0, 0, 0]
        image[grid.xartis == 1] = [255, 255, 255]
        
        for node in expanded_nodes:
            image[node] = [0, 0, 128]

        for node in frontier:
            image[node] = [0, 225, 0]

        image[self.S] = [50, 168, 64]
        image[self.F] = [168, 50, 50]
        self.images.append(image)
    
    def add_path(self, path):
        '''
          Η συνάρτηση αυτή προσθέτει στο τελευταίο frame το βέλτιστο μονοπάτι.
          Είσοδος:
          -> path: Μια λίστα η όποια περιέχει το βέλτιστο μονοπάτι (η οποία πρέπει να περιέχει και τον κόμβο αρχή και τον κόμβο στόχο)
          Έξοδος: None
        '''
        for n in path[1:-1]:
            image = np.copy(self.images[-1])
            image[n] = [66, 221, 245]
            self.images.append(image)
        for _ in range (100):
            self.images.append(image)
        
    def create_gif(self, fps = 30, repeat_delay = 2000):
        if len(self.images) == 0:
            raise EmptyStackOfImages("Error! You have to call 'draw_step' at  first.")
        fig = plt.figure()
        plt.axis('off')
        ims = []
        for img in self.images:
            img = plt.imshow(img)
            ims.append([img])
        ani = animation.ArtistAnimation(fig, ims, interval=1000//fps, blit=True, repeat_delay= repeat_delay)
        plt.close(fig)
        return ani
        
    def save_gif(self, filename, fps = 30):
        '''
            Η συνάρτηση αυτή ξαναδημιουργεί και αποθηκεύει το animation σε ένα αρχείο.
            Είσοδος:
            -> Το όνομα του αρχείου με κατάληξη .gif
            Έξοδος: (None)
        '''
        ani = self.create_gif(fps)
        writer = PillowWriter(fps= fps)
        ani.save(filename, writer=writer)

    def show_gif(self, fps= 30, repeat_delay = 2000):
        '''
            Η συνάρτηση αυτή εμφανίζει inline το animation.
            Είσοδος:
            -> fps: τα frames per second
            Έξοδος: Το αντικείμενο που παίζει το animation
            Exceptions: EmptyStackOfImages αν το animation δεν έχει ούτε ένα frame, δηλαδή αν η draw_step δεν έχει καλεστεί ποτέ.
        '''
        ani = self.create_gif(fps, repeat_delay)
        #return HTML(ani.to_html5_video())
        return HTML(ani.to_jshtml())

    def show_last_frame(self):
        '''
            Η μέθοδος αυτή εμφανίζει inline το τελευταίο frame που έχει δημιουργήθει.
            Είσοδος:
            Έξοδος: Το αντικείμενο που εμφανίζει την εικόνα.
            Exceptions: EmptyStackOfImages αν το animation δεν έχει ούτε ένα frame, δηλαδή αν η draw_step δεν έχει καλεστεί ποτέ.
        '''
        if len(self.images) == 0:
            raise EmptyStackOfImages("Error! You have to call 'draw_step' at  first.")
        else:
            plt.imshow(self.images[-1])


class EmptyStackOfImages(Exception):
    pass

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.animation import PillowWriter
from IPython.display import HTML

class Pathfinder:
    def __init__(self, maze, c, h):
        """
        maze : Αντικείμενο τύπου Maze (από Μέρος 1)
        c : Συνάρτηση που υπολογίζει την πραγματική απόσταση μεταξύ δύο σημείων
        h : Συνάρτηση που υπολογίζει την ευριστική μεταξύ δύο σημείων
        """
        self.S = maze.S
        self.F = maze.F
        self.maze = maze
        self.vis = visualization(maze.S, maze.F)
        self.path = []
        self.cost = c
        self.heuristic = h
        self.astaralgorithm()
        #EDW UA VALW THN A* KAI THA EPISTREPSW TO PATH
        ### Fill the path list with the coordinates of each point in the path from maze.S to maze.F
        ### Your code here
    def a_star_algorithm(self):
        # In this open_lst is a lisy of nodes which have been visited, but who's 
        # neighbours haven't all been always inspected, It starts off with the start 
        #H ARXH KAI TO TELOS EINAI PERASMENA STO INITIAL OBJECT
        # And closed_lst is a list of nodes which have been visited
        # and who's neighbors have been always inspected
        open_field = [self.S]
        f = self.heuristic(self.S[0],self.S[1]) + self.cost(self.S[0],self.S[1])
        more_wide_open_field = [(self.S,f)]
        closed_set = []
        least_cost = dict() #Kanw antistoixhsh monopatiou me ton xrono pou apaiteitai
        least_cost[self.S] = f
        parent = dict() #keep parent in the path
        parent[self.S] = self.S
        
        while open_field:
            #print(open_field)
            paron = open_field.pop(0)
            closed_set.append(paron)
            self.vis.draw_step(self.maze, open_field, closed_set)
            more_wide_open_field.pop(0) 
            if paron == self.F:
                self.reconstruct_path(self.F, parent)
                break
            #print(paron)
            children = self.find_child(parent, paron, least_cost)
            for i in children:
                if (i[0] not in closed_set):
                    more_wide_open_field.append(i)
            more_wide_open_field.sort(key=self.take_sec) #sort frontier according to f
            open_field = []
            #print(more_wide_open_field)
            for i in more_wide_open_field:
                open_field.append(i[0])
            
            
    def find_child(self, parent, C, best_cost):
        #print("C is {}".format(C))
        x = C[0]
        y = C[1]
        n = set()
        if x > 1 and (self.maze.xartis[(x-1,y)] == 1):
            f = self.calculate_f(x-1,y)
            if not (x-1,y) in best_cost:
                best_cost[(x-1,y)] = f
                parent[(x-1,y)] = C
                n.add(((x-1, y), f))
            elif best_cost[(x-1,y)] > f:
              #if new f from S to current cell is 
              #lower update best_cost
                parent[(x-1,y)] = C
                best_cost[(x-1,y)] = f
                n.add(((x-1, y), f))
        if x < N and (self.maze.xartis[(x+1,y)] == 1):
            f = self.calculate_f(x+1,y)
            if not (x+1,y) in best_cost:
                best_cost[(x+1,y)] = f
                parent[(x+1,y)] = C
                n.add(((x+1, y), f))
            elif best_cost[(x+1,y)] > f:
                parent[(x+1,y)] = C
                best_cost[(x+1,y)] = f
                n.add(((x+1, y), f))
        if y > 1 and (self.maze.xartis[(x,y-1)] == 1):
            f = self.calculate_f(x,y-1)
            if not (x,y-1) in best_cost:
                best_cost[(x,y-1)] = f
                parent[(x,y-1)] = C
                n.add(((x, y-1), f))
            elif best_cost[(x,y-1)] > f:
                parent[(x,y-1)] = C
                best_cost[(x,y-1)] = f
                n.add(((x, y-1), f))
        if y < N and (self.maze.xartis[(x,y+1)] == 1):
            f = self.calculate_f(x,y+1)
            if not (x,y+1) in best_cost:
                best_cost[(x,y+1)] = f
                parent[(x,y+1)] = C
                n.add(((x, y+1), f))
            elif best_cost[(x,y+1)] > f:
                parent[(x,y+1)] = C
                best_cost[(x,y+1)] = f
                n.add(((x, y+1), f))
        return n #list of children
    
    def reconstruct_path(self, C, parent):
        self.path = [self.F]
        x = C
        while(parent[x] != x):
            x = parent[x]
            self.path.append(x)
        self.path = self.path[::-1]
        
    def take_sec(self, elem):
        return elem[1]

    def get_path(self):
        return self.path
    
    def calculate_f(self,x,y):
        a = self.heuristic(x,y)
        b = self.cost(x,y)
        return a+b
    
    def astaralgorithm(self):
        self.a_star_algorithm()
        
    def get_path(self):
        return self.path

import math

## A heuristic
def my_function_manhattan(a, b):
    return (abs(a - F[0]) + abs(b - F[1]))

def my_function_euclidean(a, b):
    return math.sqrt((a - F[0])**2 + abs(b - F[1])**2)

## Create a 41x41 maze
N = 41
S = (5, 9)
F = (37, 37)
maze = Maze(N,S,F)
#maze.DFS()
## Find and visualize the path
pf = Pathfinder(maze=maze, c = lambda x, y: 1, h = my_function_euclidean)
pf2 = Pathfinder(maze=maze, c = lambda x, y: 1, h = my_function_manhattan)
pf3 = Pathfinder(maze=maze, c = lambda x, y: 1, h = lambda x, y: 0)
pf.astaralgorithm()
pf2.astaralgorithm()
pf3.astaralgorithm()
maze.draw_map(pf.get_path())
maze.draw_map(pf2.get_path())
maze.draw_map(pf3.get_path())
pf.vis.show_gif(fps=1)
pf2.vis.show_gif(fps=2)
pf3.vis.show_gif(fps=3)

#ΜΕΡΟΣ 3
#Time Complexity for DFS O(4^m) where m is the maximum depth.How can it be according to n?Maximum can be N^2/2 so O(N^2) with N the size of the maze

#______________
#   |   |   |
# | | | | | | |
# | | | | | | |
# | | | | | | |
# | | | | | | |
# | | | | | | |
# | | | | | | |
# | | | | | | |
# |___|___|___|

#Πραγματοποιήσαμε τις εξής αλλαγές:

#Αξιοποίηση κάναμε της συνάρτησης στο μέρος 1 αλλά και παραθέτουμε και έξτρα μορφή σχετικά με τον αλγόριθμο Prim .Οπότε και υλοποιήσαμε την κλάση grid2 της οποίας η συνάρτηση init λαμβάνει μία επιπλέον παράμετρο η οποία είναι μία από τις συμβολοσειρές uniform,exponential, normal,triangular. Επίσης, η κλάση αυτή περιέχει το πεδίο grid_cost το οποίο είναι ένα $(N+2)\times(N+2)$ numpy array με τιμές κελιών που προκύπτουν από μία από τις παραπάνω 3 κατανομές ανάλογα με την τιμή της τελευταίας παραμέτρου της init. Μετά την εφαρμογή των αλγορίθμων Prim και DFS που κατασκευάζουν τον λαβύριθνο grid (grid ένας numpy array αποτελούμενος από 0 και 1) θέτουμε grid[(x,y)]=grid_cost[(x,y)] αν grid[(x,y)]==0. Τελικά, κατασκευάζεται ένας χάρτης λαβυρίνθου grid ο οποίος περιέχει 1 στις θέσεις των τοίχων και έναν αριθμό στο (0,1) στις θέσεις των περασμάτων (το κόστος μετάβασης στο κελί αυτό ξεκινώντας από το κελί S). Η υλοποίηση του 2ου μέρους αυξάνει την ασυμπτωτική πολυπλοκότητα σε O(N^2). Aυτό δεν επηρεάζει την ανάλυση του 3ου Μέρους καθώς αυτή βασίζεται στο διαφορετικό μέγεθος των συνόλων path και expanded_nodes όπως αυτά προκύπτουν από τον αλγόριθμο Α* του 2ου Μέρους.

#Ακόμα, πραγματοποιήσαμε τις εξής αλλαγές στον κώδικα του 2ου Μέρους:

#Μετατρέψαμε το σύνολο expanded_nodes σε πεδίο της κλάσης pahthfinder2 και μετατρέψαμε τη συνάρτηση calculate_f του 2ου Μέρους ώστε να υπολογίζει για κάθε κελί την τιμή της συνάρτησης f=grid.grid[(x,y)]+h(x,y) (grid.grid[(x,y)]το κόστος g(n) για το κελί αυτό όπως προέκυψε στο προηγούμενο βήμα και h(x,y) η τιμή της ευρυστικής).

#Τέλος, στο μέρος MAIN παρατίθεται ο κώδικας για τη δημιουργία των ζητούμενων γραφικών παραστάσεων. Κάτω από τα διαγράμματα αναλύονται τα συμπεράσματα που προκύπτουν από αυτά. Mελετήσαμε και την περίπτωση τιμών στο διάστημα (1,2) για τις κατανομές uniform και triangular (κλήση της init της pathfinder2 με ορίσματα uniform2 και triangular2).

#Επεξήγηση των διαγραμμάτων:

#Kαι στις 3 κατανομές παρατηρούμε ότι η απουσία ευρυστικής αυξάνει πολύ το μέγεθος του expanded_nodes set. Αυτό συμβαίνει διότι οι ευριστικές αποτελούν άπληστα κριτήρια που μειώνουν το χώρο εξερεύνησης επιλέγοντας άπληστα το επόμενο βήμα με βάση το κριτήριο αυτό. Πράγματι στις γραφικές παραστάσεις expanded_nodes συναρτήσει του N η μπλε γραμμή (h(n)=0) βρίσκεται πάνω από τις γραφικές παραστάσεις (κόκκινη και πράσινη γραμμή) των ευριστικών. Επίσης, η απουσία ευριστικής που ισοδυναμεί με τον Dijkstra βρίσκει πάντα το συντομότερο μονοπάτι από τον S στον F όπως επιβεβαιώνουν και οι γραφικές του path ως συνάρτηση του Ν καθώς σε κανένα σημείο η μπλε γραμμή δεν βρίσκεται κάτω από τις άλλες δύο.

#Για τιμές κόστους στο διάστημα (1,2) παρατηρούμε τα ίδια με τα παραπάνω συμπεράσματα δηλαδή ότι η απουσία ευριστικής καταλήγει στο βέλτιστο μονοπάτι αλλά με μεγάλο σύνολο expanded_nodes το οποίο συνεπάγεται μεγάλο χρόνο εκτέλεσης. Ομοίως και για τιμές κόστους στο διάστημα (0,0.1) όπου τα παραπάνω συμπεράσματα γίονται ακόμη πιο εμφανή καθώς πρακτικά η g(n) είναι μηδενική.

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
from queue import LifoQueue
from random import shuffle, uniform
import random as rnd
import matplotlib.pyplot as plt
from numpy import random
import scipy.stats
from scipy.stats import norm, expon
 
class Maze2:
    def __init__(self, N, S, F, distr):
        
        ## Make sure start and end are within the grid
        assert N > 2
        assert S[0] < (N+1)
        assert S[1] < (N+1)
        assert F[0] < (N+1)
        assert F[1] < (N+1)
        assert S[0] > 0
        assert S[1] > 0
        assert F[0] > 0
        assert F[1] > 0

        self.N = N
        self.distribution = distr

        ## Initialize grid with obstacles, make margins walls
        ## wall(obstacle) = 1, passage = 0
        self.grid = np.ones((N+2, N+2), dtype=np.float32) #change to float to support the
        #results of the distribution (0,1)
        self.grid_cost = np.ones((N+2, N+2), dtype=np.float32)
        if (self.distribution == "uniform"):
            for x in range (0,N+2):
                for y in range (0,N+2):
                    self.grid_cost[(x,y)] = scipy.stats.uniform(0, 1).cdf((x+y)/1000)
            #self.grid_cost = random.uniform(size=(self.N+2, self.N+2))
        elif (self.distribution == "normal"):
            for x in range (0,N+2):
                for y in range (0,N+2):
                    self.grid_cost[(x,y)] = scipy.stats.norm(0, 1).cdf((x+y)/1000)
        elif (self.distribution == "exponential"):
            for x in range (0,N+2):
                for y in range (0,N+2):
                    self.grid_cost[(x,y)] = scipy.stats.expon(0, 1).cdf((x+y)/1000)
        elif (self.distribution == "uniform2"):
            self.grid_cost = random.uniform(1,2,size=(self.N+2, self.N+2))
        elif (self.distribution == "triangular2"):
            self.grid_cost = random.triangular(1, 1.5, 2, size=(self.N+2,self.N+2))

            
        ## Start and end position have no obstacles
        self.grid[S]=0
        self.grid[F]=0
        obstacle_free_points = {S, F} 
        frontier = set() 
        visited = {S} #contains all visited cells of the grid
        # walls and passages
        ##implemantation of Randomized Prim's Algorithm
        for f in self.find_frontier(S):
            frontier.add(f)
            visited.add(f)
        
        while frontier:
            W = rnd.choice(tuple(frontier)) ##choose a wall in random
            #check if the wall will be destroyed or not 
            # according to Prim's algorithm
            self.check_wall(W, frontier, obstacle_free_points, visited)
            frontier.remove(W)
        self.connect_S_F(F, obstacle_free_points)
        ##Set random costs in cells in (0,1) 
        for i in range (1,self.N+2):
            for j in range (1,self.N+2):
                if (self.grid[(i,j)] == 0):
                    self.grid[(i,j)] = self.grid_cost[(i,j)]
        
        
    def check_wall(self,W, frontier, free_points, visited):
        x = W[0]
        y = W[1]
        ##Don't destroy the wall if it has more than 1 passages around
        ## it. This check results to better designed mazes.
        cnt = self.count_passages(W)
        if cnt < 2:
            if (x > 1 and x < N) and ((x-1,y) in visited and not((x+1,y) in visited)):
                self.grid[W] = 0
                self.grid[(x+1,y)] = 0
                free_points.add(W)
                free_points.add((x+1,y))
                visited.add((x+1,y))
                ##update the frontier 
                for i in self.find_frontier(W):
                    frontier.add(i)
                for i in self.find_frontier((x+1,y)):
                    frontier.add(i)
            elif (x > 1 and x < N) and (not ((x-1,y) in visited) and ((x+1,y) in visited)):
                self.grid[W] = 0
                self.grid[(x-1,y)] = 0
                free_points.add(W)
                free_points.add((x-1,y))
                visited.add((x-1,y))
                for i in self.find_frontier(W):
                    frontier.add(i)
                for i in self.find_frontier((x-1,y)):
                    frontier.add(i)
            elif (y > 1 and y < N) and ((x,y-1) in visited and not((x,y+1) in visited)):
                self.grid[W] = 0
                self.grid[(x,y+1)] = 0
                free_points.add(W)
                free_points.add((x,y+1))
                visited.add((x,y+1))    
                for i in self.find_frontier(W):
                    frontier.add(i)
                for i in self.find_frontier((x,y+1)):
                    frontier.add(i)
            elif (y > 1 and y < N) and (not((x,y-1) in visited) and ((x,y+1) in visited)):
                self.grid[W] = 0
                self.grid[(x,y-1)] = 0
                free_points.add(W)
                free_points.add((x,y-1))
                visited.add((x,y-1))
                for i in self.find_frontier(W):
                    frontier.add(i)
                for i in self.find_frontier((x,y-1)):
                    frontier.add(i)

    def count_passages(self,W):
        n = self.find_neighbors(W)
        return len(n)
        
    ##find cells with value 0 adjacented to cell C    
    def find_neighbors(self, C):
        x = C[0]
        y = C[1]
        n = set()
        if x > 1 and (self.grid[(x-1,y)] == 0):
            n.add((x-1, y))
        if x < N and (self.grid[(x+1,y)] == 0):
            n.add((x+1, y))
        if y > 1 and (self.grid[(x,y-1)] == 0):
            n.add((x, y-1))
        if y < N and (self.grid[(x,y+1)] == 0):
            n.add((x, y+1))
        return n
        
    ##find cells with value 1 adjacented to cell C
    def find_frontier(self, C):
        x = C[0]
        y = C[1]
        f = set()
        if x > 1 and (self.grid[(x-1,y)] == 1):
            f.add((x-1, y))
        if x < N and (self.grid[(x+1,y)] == 1):
            f.add((x+1, y))
        if y > 1 and (self.grid[(x,y-1)] == 1):
            f.add((x, y-1))
        if y < N and (self.grid[(x,y+1)] == 1):
            f.add((x, y+1))
        return f
            
    ## Implement DFS starting from F, stop when you find
    ## a cell that is a passage (0). Because the maze was produced 
    ## using Prim's Algorithm, which produces spanning trees, all the 
    ## cells which belong to the maze are connected (a tree is a connected graph).
    ## So, implementing DFS starting from F and making all the cells at the path from F
    ## to a cell with value "0" has as a result a path from S to F
    
    def connect_S_F(self, F, obstacle_free_points):
        st = [] #DFS stack
        visited = set()
        st.append(F)
        visited = set()
        while st:
            current = st.pop(0)
            if current not in visited:
                self.grid[current] = 0
                obstacle_free_points.add(current)
                visited.add(current)
                neigh = self.find_neighbors(current)
                if neigh:
                    break
                walls = self.find_frontier(current)
                for w in walls:
                    st.append(w)
   

for N, S, F in ((11, (1, 3), (7, 8)), (25, (2, 7), (23, 19)), (51, (10, 2), (42, 42))):
    map = Maze2(N, S, F, "uniform")

## Modification of Code 2 for Part 3
# from visualization import *

class Pathfinder2:
    def __init__(self, S, F, grid, c, h):
        self.S = S
        self.F = F
        self.grid = grid
        self.cost = c
        self.heuristic = h
        #for visualization 
        #self.vis = visualization(S, F)
        self.path=[]
        self.expanded_nodes = [] #closed set
        self.find_path()

    def find_path(self):
        ## A* Algorithm
        frontier = [self.S]
        f = self.calculate_f(self.S[0], self.S[1])
        frontier2 = [(self.S,f)] #contains triples ((x,y),f)
        best_cost = dict() #best_cost[C] = min f for cell C so far
        best_cost[self.S] = f
        parent = dict() #keep parent in the path
        parent[self.S] = self.S

        while frontier:
            current = frontier.pop(0)
            self.expanded_nodes.append(current)
            #self.vis.draw_step(self.grid, frontier, expanded_nodes)
            frontier2.pop(0) 
            if current == self.F:
                self.reconstruct_path(self.F, parent)
                break
            children = self.find_child(parent, current, best_cost)
            for i in children:
                if (i[0] not in self.expanded_nodes):
                    frontier2.append(i)
            frontier2.sort(key=self.take_sec) #sort frontier according to f
            frontier = []
            for i in frontier2:
                frontier.append(i[0])
            
            
    def find_child(self, parent, C, best_cost):
        x = C[0]
        y = C[1]
        n = set()
        if x > 1 and (self.grid.grid[(x-1,y)] != 1):
            f = self.calculate_f(x-1,y)
            if not (x-1,y) in best_cost:
                best_cost[(x-1,y)] = f
                parent[(x-1,y)] = C
                n.add(((x-1, y), f))
            elif best_cost[(x-1,y)] > f:
                parent[(x-1,y)] = C
                best_cost[(x-1,y)] = f
                n.add(((x-1, y), f))
        if x < N and (self.grid.grid[(x+1,y)] != 1):
            f = self.calculate_f(x+1,y)
            if not (x+1,y) in best_cost:
                best_cost[(x+1,y)] = f
                parent[(x+1,y)] = C
                n.add(((x+1, y), f))
            elif best_cost[(x+1,y)] > f:
                parent[(x+1,y)] = C
                best_cost[(x+1,y)] = f
                n.add(((x+1, y), f))
        if y > 1 and (self.grid.grid[(x,y-1)] != 1):
            f = self.calculate_f(x,y-1)
            if not (x,y-1) in best_cost:
                best_cost[(x,y-1)] = f
                parent[(x,y-1)] = C
                n.add(((x, y-1), f))
            elif best_cost[(x,y-1)] > f:
                parent[(x,y-1)] = C
                best_cost[(x,y-1)] = f
                n.add(((x, y-1), f))
        if y < N and (self.grid.grid[(x,y+1)] != 1):
            f = self.calculate_f(x,y+1)
            if not (x,y+1) in best_cost:
                best_cost[(x,y+1)] = f
                parent[(x,y+1)] = C
                n.add(((x, y+1), f))
            elif best_cost[(x,y+1)] > f:
                parent[(x,y+1)] = C
                best_cost[(x,y+1)] = f
                n.add(((x, y+1), f))
        return n #list of children
    
    def reconstruct_path(self, C, parent):
        self.path = [self.F]
        x = C
        while(parent[x] != x):
            x = parent[x]
            self.path.append(x)
        self.path = self.path[::-1]
        
    def take_sec(self, elem):
        return elem[1]

    def get_path(self):
        return self.path
    
    def calculate_f(self,x,y):
        a = self.heuristic(x,y)
        b = self.grid.grid[(x,y)]
        return a+b

import time 
# %matplotlib inline
import numpy as np
from queue import LifoQueue
from PIL import Image
from matplotlib import image
import random 
import time
import matplotlib.pyplot as plt
from numpy import asarray
from collections import deque

for N,S,F in ((11, (1, 3), (7, 9)), (41, (5,9), (37,37))):
        start_time = time.time()
        mazess = Maze(N,S,F)
        mazess.DFS()
        end_time = time.time()

        time_elapsed_dfs = (end_time - start_time)
        print("For DFS, for these standard info, time required is : " + str(time_elapsed_dfs))
        start_time = time.time()
        maze2 = Maze2(N,S,F,distr = "uniform")
        end_time = time.time()
        time_elapsed_prim = (end_time - start_time)
        print("For Prim, for these standard info, time required is : " + str(time_elapsed_prim))
        
## Part 3 - Main 
li = np.arange(3, 100, 5)
#UNIFORM
ump = []
uep = []
uh0p = []
ume = []
uee = []
uh0e = []
for N in li:
    S = (1,1)
    F = (N,N)
    newmap = Maze2(N, S, F, "uniform")
    m = Pathfinder2(S, F, newmap, lambda x, y: 0, my_function_manhattan)
    ump.append(len(m.path))
    ume.append(len(m.expanded_nodes))
    e = Pathfinder2(S, F, newmap, lambda x, y: 0, my_function_euclidean)
    uep.append(len(e.path))
    uee.append(len(e.expanded_nodes))
    h0 = Pathfinder2(S, F, newmap, lambda x, y: 0, lambda x, y: 0)
    uh0p.append(len(h0.path))
    uh0e.append(len(h0.expanded_nodes))
plt.figure()
plt.xlabel("Maze Size")
plt.ylabel("Path size")
plt.suptitle("Uniform")
#fig1 = plt.plot(li, ump,'r',label="Manhattan",li, uep,'g', li, uh0p, 'b')
plt.plot(li, ump,'r',label="Manhattan")
plt.plot(li, uep,'g',label="Euclidean")
plt.plot(li, uh0p,'b',label="h=0")
plt.legend(loc="upper left")
#plt.legend((ump, uep, uh0p), ('Manhattan', 'Euclidean', 'h=0'))
plt.figure()
plt.xlabel("Maze Size")
plt.ylabel("Expanded nodes")
plt.suptitle("Uniform")
plt.plot(li, ume,'r',label="Manhattan")
plt.plot(li, uee,'g',label="Euclidean")
plt.plot(li, uh0e,'b',label="h=0")
plt.legend(loc="upper left")

#GAUSSIAN
gmp = []
gep = []
gh0p = []
gme = []
gee = []
gh0e = []
for N in li:
    S = (1,1)
    F = (N-2,N-2)
    map = Maze2(N, S, F, "normal")
    m = Pathfinder2(S, F, map, lambda x, y: 0, my_function_manhattan)
    gmp.append(len(m.path))
    gme.append(len(m.expanded_nodes))
    e = Pathfinder2(S, F, map, lambda x, y: 0, my_function_euclidean)
    gep.append(len(e.path))
    gee.append(len(e.expanded_nodes))
    h0 = Pathfinder2(S, F, map, lambda x, y: 0, lambda x, y: 0)
    gh0p.append(len(h0.path))
    gh0e.append(len(h0.expanded_nodes))

plt.figure()
plt.xlabel("Maze Size")
plt.ylabel("Path size")
plt.suptitle("Gaussian")
#fig1 = plt.plot(li, ump,'r',label="Manhattan",li, uep,'g', li, uh0p, 'b')
plt.plot(li, gmp,'r',label="Manhattan")
plt.plot(li, gep,'g',label="Euclidean")
plt.plot(li, gh0p,'b',label="h=0")
plt.legend(loc="upper left")
#plt.legend((ump, uep, uh0p), ('Manhattan', 'Euclidean', 'h=0'))
plt.figure()
plt.xlabel("Maze Size")
plt.ylabel("Expanded nodes")
plt.suptitle("Gaussian")
plt.plot(li, gme,'r',label="Manhattan")
plt.plot(li, gee,'g',label="Euclidean")
plt.plot(li, gh0e,'b',label="h=0")
plt.legend(loc="upper left")

#EXPONENTIAL
emp = []
eep = []
eh0p = []
eme = []
eee = []
eh0e = []
for N in li:
    S = (1,1)
    F = (N,N)
    map = Maze2(N, S, F, "exponential")
    m = Pathfinder2(S, F, map, lambda x, y: 0, my_function_manhattan)
    emp.append(len(m.path))
    eme.append(len(m.expanded_nodes))
    e = Pathfinder2(S, F, map, lambda x, y: 0, my_function_euclidean)
    eep.append(len(e.path))
    eee.append(len(e.expanded_nodes))
    h0 = Pathfinder2(S, F, map, lambda x, y: 0, lambda x, y: 0)
    eh0p.append(len(h0.path))
    eh0e.append(len(h0.expanded_nodes))
plt.figure()
plt.xlabel("Maze Size")
plt.ylabel("Path size")
plt.suptitle("Exponential")
#fig1 = plt.plot(li, ump,'r',label="Manhattan",li, uep,'g', li, uh0p, 'b')
plt.plot(li, emp,'r',label="Manhattan")
plt.plot(li, eep,'g',label="Euclidean")
plt.plot(li, eh0p,'b',label="h=0")
plt.legend(loc="upper left")
#plt.legend((ump, uep, uh0p), ('Manhattan', 'Euclidean', 'h=0'))
plt.figure()
plt.xlabel("Maze Size")
plt.ylabel("Expanded nodes")
plt.suptitle("Exponential")
plt.plot(li, eme,'r',label="Manhattan")
plt.plot(li, eee,'g',label="Euclidean")
plt.plot(li, eh0e,'b',label="h=0")
plt.legend(loc="upper left")

#Analysis for values in (1,2)
#Uniform and Triangular
li = np.arange(3, 100, 5)
u2mp = []
u2ep = []
u2h0p = []
u2me = []
u2ee = []
u2h0e = []

temporary = []
tep = []
th0p = []
tme = []
tee = []
th0e = []
for N in li:
    S = (1,1)
    F = (N,N)
    map = Maze2(N, S, F, "uniform2")
    map2 = Maze2(N, S, F, "triangular2")
    m = Pathfinder2(S, F, map, lambda x, y: 0, my_function_manhattan)
    u2mp.append(len(m.path))
    u2me.append(len(m.expanded_nodes))
    e = Pathfinder2(S, F, map, lambda x, y: 0, my_function_euclidean)
    u2ep.append(len(e.path))
    u2ee.append(len(e.expanded_nodes))
    h0 = Pathfinder2(S, F, map, lambda x, y: 0, lambda x, y: 0)
    u2h0p.append(len(h0.path))
    u2h0e.append(len(h0.expanded_nodes))
    m2 = Pathfinder2(S, F, map2, lambda x, y: 0, my_function_manhattan)
    tmp.append(len(m.path))
    tme.append(len(m.expanded_nodes))
    e2 = Pathfinder2(S, F, map2, lambda x, y: 0, my_function_euclidean)
    tep.append(len(e.path))
    tee.append(len(e.expanded_nodes))
    h02 = Pathfinder2(S, F, map2, lambda x, y: 0, lambda x, y: 0)
    th0p.append(len(h0.path))
    th0e.append(len(h0.expanded_nodes))
plt.figure()
plt.xlabel("Maze Size")
plt.ylabel("Path size")
plt.suptitle("Uniform (1,2)")
#fig1 = plt.plot(li, ump,'r',label="Manhattan",li, uep,'g', li, uh0p, 'b')
plt.plot(li, u2mp,'r',label="Manhattan")
plt.plot(li, u2ep,'g',label="Euclidean")
plt.plot(li, u2h0p,'b',label="h=0")
plt.legend(loc="upper left")
#plt.legend((ump, uep, uh0p), ('Manhattan', 'Euclidean', 'h=0'))
plt.figure()
plt.xlabel("Maze Size")
plt.ylabel("Expanded nodes")
plt.suptitle("Uniform (1,2)")
plt.plot(li, u2me,'r',label="Manhattan")
plt.plot(li, u2ee,'g',label="Euclidean")
plt.plot(li, u2h0e,'b',label="h=0")
plt.legend(loc="upper left")
plt.figure()
plt.xlabel("Maze Size")
plt.ylabel("Path size")
plt.suptitle("Triangular (1,2)")
#fig1 = plt.plot(li, ump,'r',label="Manhattan",li, uep,'g', li, uh0p, 'b')
plt.plot(li, temporary,'r',label="Manhattan")
plt.plot(li, tep,'g',label="Euclidean")
plt.plot(li, th0p,'b',label="h=0")
plt.legend(loc="upper left")
#plt.legend((ump, uep, uh0p), ('Manhattan', 'Euclidean', 'h=0'))
plt.figure()
plt.xlabel("Maze Size")
plt.ylabel("Expanded nodes")
plt.suptitle("Triangular (1,2)")
plt.plot(li, tme,'r',label="Manhattan")
plt.plot(li, tee,'g',label="Euclidean")
plt.plot(li, th0e,'b',label="h=0")
plt.legend(loc="upper left")

#ΣΥΝΕΠΩΣ ΚΑΙ ΑΠΟ ΤΗΝ ΣΥΓΚΡΙΣΗ ΑΡΚΕΤΩΝ ΓΡΑΦΙΚΩΝ ΠΑΡΑΣΤΑΣΤΕΩΝ, ΕΙΝΑΙ ΚΑΛΥΤΕΡΗ ΚΑΙ ΠΙΟ ΑΞΙΟΠΙΣΤΗ Η ΕΥΡΕΣΗ ΤΟΥ ΤΕΛΙΚΟΥ ΜΟΥ ΑΠΟΤΕΛΕΣΜΑΤΟΣ